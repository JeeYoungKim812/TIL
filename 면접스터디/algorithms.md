# 그래프?

- 노드와 노드를 연결하는 간선을 하나로 모아놓은 비선형 자료구조입니다.

# Queue vs Stack?

- 큐는 First In First Out의 구조를 갖고 있습니다. 큐는 은행 창구나 콜센터를 예시로 들 수 있습니다.

---

- 스택은 Last In First Out의 구조를 갖고 있습니다. 스택은 택배 상하차를 예시로 들 수 있습니다.

# BFS?

- 너비우선탐색입니다. 너비우선탐색은 최단 경로를 찾아준다는 점에서 최단 길이를 보장해야 할 때 많이 사용합니다.
- Queue를 이용해 주로 구현합니다.
- 시작 노드를 큐에 삽입하면서 시작합니다.
- 큐에서 하나의 노드를 꺼내고 해당 노드와 연결된 노드 중 방문하지 않은 노드에 방문 후 차례대로 큐에 삽입합니다. 이를 반복합니다. 모든 노드에 방문하면 큐에 남은 노드를 꺼내줍니다.

# DFS?

- 그래프 탐색의 한 종류인 깊이우선탐색입니다.
- Stack을 이용해 주로 구현합니다.
- 특정 노드에서 시작해 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법입니다.

# Dijkstra?

- 최단 경로 탐색 알고리즘입니다. 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단경로를 알려줍니다.
- 최단거리는 여러개의 최단거리로 이루어져있다는 특성을 활용한 알고리즘입니다. 현재까지 알고 있던 최단경로를 계속해서 갱신합니다.

# Bellmanford?







# 이진트리 순회방식

- 전위순회: 자기자신 -> 왼쪽 자식노드 -> 오른쪽 자식노드
- 중위순회: 왼쪽 자식노드 -> 자기자신 -> 오른쪽 자식노드
- 후위순회: 왼쪽 자식노드 -> 오른쪽 자식노드 -> 자기자신

# AVL tree?







# B+ tree?

- 

# Quick sort vs Merge sort?

- 퀵소트는 분할을 통해 정렬을 진행합니다. 배열 중 한 원소를 피봇으로 정한 뒤 이 피봇보다 작은 원소와 큰 원소로 나눕니다. 나눈 배열에 대해 재귀적으로 함수를 실행시키는 방법으로 정렬을 진행합니다.
- 최악의 경우 시간복잡도는  O(n²) 이며 최선의 경우에는 O(n log n) 입니다.

---

- 머지소트도 퀵소트와 마찬가지로 분할을 통해 정렬을 진행합니다. 배열을 쪼갠 후 정렬하고, 정렬된 요소를 합병해서 반복합니다.
- 시간복잡도는 O(n log n) 입니다.
- 배열을 계속 생성하는 방식으로 정렬을 진행하기 때문에 공간복잡도가 높습니다.

# 버블소트?

- 인접한 두 원소를 비교해 자리를 교환해서 정렬하는 방법입니다.
- 구현이 간단하고 소스코드도 직관적이어서 자주 사용되지만 시간 복잡도가 O(n²) 으로 비효율적인 정렬방법입니다.



# Heap?

- 힙은 최솟값이나 최대값을 빠르게 찾아내기 위해 완전 이진트리를 기반으로 하는 트리입니다. 힙에는 최대 힙과 최소 힙이 존재하는데, 최대 힙은 부모 노드가 자식 노드보다 큰 힙입니다.

# Heap sort?

- https://gaemi606.tistory.com/entry/%ED%9E%99-%EC%A0%95%EB%A0%ACHeap-sort?category=785070 
- 특정한 노드의 두 자식노드의 값 중에서 더 큰 자식과 자신의 위치를 바꾸며 정렬하는 방법입니다.

# 그리디 알고리즘?

- 
